using System;
using System.Collections.Generic;
using System.Runtime.InteropServices;
using T3DSharpFramework.Engine;
using T3DSharpFramework.Engine.Util;
using T3DSharpFramework.Generated.Classes.Global;
using T3DSharpFramework.Generated.Classes.Reflection;
using T3DSharpFramework.Generated.Classes.Sim;
using T3DSharpFramework.Generated.Classes.Sim.Net;
using T3DSharpFramework.Generated.Enums.Global;
using T3DSharpFramework.Generated.Enums.Reflection;
using T3DSharpFramework.Generated.Structs.Global;
using T3DSharpFramework.Generated.Structs.Gui;
using T3DSharpFramework.Generated.Structs.Math;
using T3DSharpFramework.Interop;

namespace T3DSharpFramework.Generated.Classes.Sim {
    /// <summary>A material in Torque 3D is a data structure that describes a surface.</summary>
    /// <description>
    /// It contains many different types of information for rendering properties. Torque 3D generates shaders from Material definitions. The shaders are compiled at runtime and output into the example/shaders directory. Any errors or warnings generated from compiling the procedurally generated shaders are output to the console as well as the output window in the Visual C IDE.
    /// </description>
    /// <code>
    /// singleton Material(DECAL_scorch)
    /// {
    /// 	baseTex[0] = "./scorch_decal.png";
    /// 	vertColor[ 0 ] = true;
    /// 
    /// 	translucent = true;
    /// 	translucentBlendOp = None;
    /// 	translucentZWrite = true;
    /// 	alphaTest = true;
    /// 	alphaRef = 84;
    /// };
    /// </code>
    /// <see cref="Rendering" />
    /// <see cref="ShaderData" />
    public unsafe class Material : SimObject {
        public Material(bool pRegister = false) 
            : base(pRegister) {
        }
        
        public Material(string pName, bool pRegister) 
            : this(false) {
            Name = pName;
            if (pRegister) {
                RegisterObject();
            }
        }
        
        public Material(string pName) 
            : this(pName, false) {
        }
        
        public Material(string pName, string pParent, bool pRegister = false) 
            : this(pName, pRegister) {
            CopyFrom(Engine.Sim.FindObject<SimObject>(pParent));
        }
        
        public Material(string pName, SimObject pParent, bool pRegister = false) 
            : this(pName, pRegister) {
            CopyFrom(pParent);
        }
        
        public Material(SimObject pObj) 
            : base(pObj) {
        }
        
        public Material(IntPtr pObj) 
            : base(pObj) {
        }
        
		protected override void CreateObjectPtr()
		{
			ObjectPtr = InternalUnsafeMethods.Create()(new InternalUnsafeMethods.Create__Args());
		}

        #region UnsafeNativeMethods
        new internal struct InternalUnsafeMethods {
            [StructLayout(LayoutKind.Sequential)]
            internal struct GetAutogeneratedFile__Args
            {
            }

            [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
            
            internal delegate IntPtr _GetAutogeneratedFile(IntPtr _this, GetAutogeneratedFile__Args args);
            private static _GetAutogeneratedFile _GetAutogeneratedFileFunc;
            internal static _GetAutogeneratedFile GetAutogeneratedFile() {
                if (_GetAutogeneratedFileFunc == null) {
                    _GetAutogeneratedFileFunc =
                        (_GetAutogeneratedFile)Marshal.GetDelegateForFunctionPointer(
                            Torque3D.DllLoadUtils.GetProcAddress(
                                Torque3D.Torque3DLibHandle,
                                "fnMaterial_getAutogeneratedFile"), typeof(_GetAutogeneratedFile));
                }
                
                return _GetAutogeneratedFileFunc;
            }

            [StructLayout(LayoutKind.Sequential)]
            internal struct SetAutoGenerated__Args
            {
                [MarshalAs(UnmanagedType.I1)]
                internal bool isAutoGenerated;
            }

            [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
            internal delegate void _SetAutoGenerated(IntPtr _this, SetAutoGenerated__Args args);
            private static _SetAutoGenerated _SetAutoGeneratedFunc;
            internal static _SetAutoGenerated SetAutoGenerated() {
                if (_SetAutoGeneratedFunc == null) {
                    _SetAutoGeneratedFunc =
                        (_SetAutoGenerated)Marshal.GetDelegateForFunctionPointer(
                            Torque3D.DllLoadUtils.GetProcAddress(
                                Torque3D.Torque3DLibHandle,
                                "fnMaterial_setAutoGenerated"), typeof(_SetAutoGenerated));
                }
                
                return _SetAutoGeneratedFunc;
            }

            [StructLayout(LayoutKind.Sequential)]
            internal struct IsAutoGenerated__Args
            {
            }

            [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
            [return: MarshalAs(UnmanagedType.I1)]
            internal delegate bool _IsAutoGenerated(IntPtr _this, IsAutoGenerated__Args args);
            private static _IsAutoGenerated _IsAutoGeneratedFunc;
            internal static _IsAutoGenerated IsAutoGenerated() {
                if (_IsAutoGeneratedFunc == null) {
                    _IsAutoGeneratedFunc =
                        (_IsAutoGenerated)Marshal.GetDelegateForFunctionPointer(
                            Torque3D.DllLoadUtils.GetProcAddress(
                                Torque3D.Torque3DLibHandle,
                                "fnMaterial_isAutoGenerated"), typeof(_IsAutoGenerated));
                }
                
                return _IsAutoGeneratedFunc;
            }

            [StructLayout(LayoutKind.Sequential)]
            internal struct GetFilename__Args
            {
            }

            [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
            
            internal delegate IntPtr _GetFilename(IntPtr _this, GetFilename__Args args);
            private static _GetFilename _GetFilenameFunc;
            internal static _GetFilename GetFilename() {
                if (_GetFilenameFunc == null) {
                    _GetFilenameFunc =
                        (_GetFilename)Marshal.GetDelegateForFunctionPointer(
                            Torque3D.DllLoadUtils.GetProcAddress(
                                Torque3D.Torque3DLibHandle,
                                "fnMaterial_getFilename"), typeof(_GetFilename));
                }
                
                return _GetFilenameFunc;
            }

            [StructLayout(LayoutKind.Sequential)]
            internal struct GetAnimFlags__Args
            {
                internal uint id;
            }

            [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
            
            internal delegate IntPtr _GetAnimFlags(IntPtr _this, GetAnimFlags__Args args);
            private static _GetAnimFlags _GetAnimFlagsFunc;
            internal static _GetAnimFlags GetAnimFlags() {
                if (_GetAnimFlagsFunc == null) {
                    _GetAnimFlagsFunc =
                        (_GetAnimFlags)Marshal.GetDelegateForFunctionPointer(
                            Torque3D.DllLoadUtils.GetProcAddress(
                                Torque3D.Torque3DLibHandle,
                                "fnMaterial_getAnimFlags"), typeof(_GetAnimFlags));
                }
                
                return _GetAnimFlagsFunc;
            }

            [StructLayout(LayoutKind.Sequential)]
            internal struct GetMaterialInstances__Args
            {
                internal IntPtr matTree;
            }

            [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
            internal delegate void _GetMaterialInstances(IntPtr _this, GetMaterialInstances__Args args);
            private static _GetMaterialInstances _GetMaterialInstancesFunc;
            internal static _GetMaterialInstances GetMaterialInstances() {
                if (_GetMaterialInstancesFunc == null) {
                    _GetMaterialInstancesFunc =
                        (_GetMaterialInstances)Marshal.GetDelegateForFunctionPointer(
                            Torque3D.DllLoadUtils.GetProcAddress(
                                Torque3D.Torque3DLibHandle,
                                "fnMaterial_getMaterialInstances"), typeof(_GetMaterialInstances));
                }
                
                return _GetMaterialInstancesFunc;
            }

            [StructLayout(LayoutKind.Sequential)]
            internal struct DumpInstances__Args
            {
            }

            [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
            internal delegate void _DumpInstances(IntPtr _this, DumpInstances__Args args);
            private static _DumpInstances _DumpInstancesFunc;
            internal static _DumpInstances DumpInstances() {
                if (_DumpInstancesFunc == null) {
                    _DumpInstancesFunc =
                        (_DumpInstances)Marshal.GetDelegateForFunctionPointer(
                            Torque3D.DllLoadUtils.GetProcAddress(
                                Torque3D.Torque3DLibHandle,
                                "fnMaterial_dumpInstances"), typeof(_DumpInstances));
                }
                
                return _DumpInstancesFunc;
            }

            [StructLayout(LayoutKind.Sequential)]
            internal struct Reload__Args
            {
            }

            [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
            internal delegate void _Reload(IntPtr _this, Reload__Args args);
            private static _Reload _ReloadFunc;
            internal static _Reload Reload() {
                if (_ReloadFunc == null) {
                    _ReloadFunc =
                        (_Reload)Marshal.GetDelegateForFunctionPointer(
                            Torque3D.DllLoadUtils.GetProcAddress(
                                Torque3D.Torque3DLibHandle,
                                "fnMaterial_reload"), typeof(_Reload));
                }
                
                return _ReloadFunc;
            }

            [StructLayout(LayoutKind.Sequential)]
            internal struct Flush__Args
            {
            }

            [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
            internal delegate void _Flush(IntPtr _this, Flush__Args args);
            private static _Flush _FlushFunc;
            internal static _Flush Flush() {
                if (_FlushFunc == null) {
                    _FlushFunc =
                        (_Flush)Marshal.GetDelegateForFunctionPointer(
                            Torque3D.DllLoadUtils.GetProcAddress(
                                Torque3D.Torque3DLibHandle,
                                "fnMaterial_flush"), typeof(_Flush));
                }
                
                return _FlushFunc;
            }

            [StructLayout(LayoutKind.Sequential)]
            internal struct StaticGetType__Args
            {
            }

            [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
            internal delegate IntPtr _StaticGetType(StaticGetType__Args args);
            private static _StaticGetType _StaticGetTypeFunc;
            internal static _StaticGetType StaticGetType() {
                if (_StaticGetTypeFunc == null) {
                    _StaticGetTypeFunc =
                        (_StaticGetType)Marshal.GetDelegateForFunctionPointer(
                            Torque3D.DllLoadUtils.GetProcAddress(
                                Torque3D.Torque3DLibHandle,
                                "fnMaterial_staticGetType"), typeof(_StaticGetType));
                }
                
                return _StaticGetTypeFunc;
            }

            [StructLayout(LayoutKind.Sequential)]
            internal struct Create__Args
            {
            }

            [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
            internal delegate IntPtr _Create(Create__Args args);
            private static _Create _CreateFunc;
            internal static _Create Create() {
                if (_CreateFunc == null) {
                    _CreateFunc =
                        (_Create)Marshal.GetDelegateForFunctionPointer(
                            Torque3D.DllLoadUtils.GetProcAddress(
                                Torque3D.Torque3DLibHandle,
                                "fnMaterial_create"), typeof(_Create));
                }
                
                return _CreateFunc;
            }
        }
        #endregion

        /// <description>
        /// Get filename of autogenerated shader file
        /// </description>
        public string GetAutogeneratedFile() {
             InternalUnsafeMethods.GetAutogeneratedFile__Args _args = new InternalUnsafeMethods.GetAutogeneratedFile__Args() {
             };
             IntPtr _engineResult = InternalUnsafeMethods.GetAutogeneratedFile()(ObjectPtr, _args);
             return StringMarshal.IntPtrToUtf8String(_engineResult);
        }

        /// <description>
        /// setAutoGenerated(bool isAutoGenerated): Set whether or not the Material is autogenerated.
        /// </description>
        public void SetAutoGenerated(bool isAutoGenerated) {
             InternalUnsafeMethods.SetAutoGenerated__Args _args = new InternalUnsafeMethods.SetAutoGenerated__Args() {
                isAutoGenerated = isAutoGenerated,
             };
             InternalUnsafeMethods.SetAutoGenerated()(ObjectPtr, _args);
        }

        /// <description>
        /// Returns true if this Material was automatically generated by MaterialList::mapMaterials()
        /// </description>
        public bool IsAutoGenerated() {
             InternalUnsafeMethods.IsAutoGenerated__Args _args = new InternalUnsafeMethods.IsAutoGenerated__Args() {
             };
             bool _engineResult = InternalUnsafeMethods.IsAutoGenerated()(ObjectPtr, _args);
             return _engineResult;
        }

        /// <description>
        /// Get filename of material
        /// </description>
        public string GetFilename() {
             InternalUnsafeMethods.GetFilename__Args _args = new InternalUnsafeMethods.GetFilename__Args() {
             };
             IntPtr _engineResult = InternalUnsafeMethods.GetFilename()(ObjectPtr, _args);
             return StringMarshal.IntPtrToUtf8String(_engineResult);
        }

        /// 
        public string GetAnimFlags(uint id) {
             InternalUnsafeMethods.GetAnimFlags__Args _args = new InternalUnsafeMethods.GetAnimFlags__Args() {
                id = id,
             };
             IntPtr _engineResult = InternalUnsafeMethods.GetAnimFlags()(ObjectPtr, _args);
             return StringMarshal.IntPtrToUtf8String(_engineResult);
        }

        /// <description>
        /// Dumps a formatted list of the currently allocated material instances for this material to the console.
        /// </description>
        public void GetMaterialInstances(GuiTreeViewCtrl matTree = null) {
             InternalUnsafeMethods.GetMaterialInstances__Args _args = new InternalUnsafeMethods.GetMaterialInstances__Args() {
                matTree = matTree.ObjectPtr,
             };
             InternalUnsafeMethods.GetMaterialInstances()(ObjectPtr, _args);
        }

        /// <description>
        /// Dumps a formatted list of the currently allocated material instances for this material to the console.
        /// </description>
        public void DumpInstances() {
             InternalUnsafeMethods.DumpInstances__Args _args = new InternalUnsafeMethods.DumpInstances__Args() {
             };
             InternalUnsafeMethods.DumpInstances()(ObjectPtr, _args);
        }

        /// <description>
        /// Reloads all material instances that use this material.
        /// </description>
        public void Reload() {
             InternalUnsafeMethods.Reload__Args _args = new InternalUnsafeMethods.Reload__Args() {
             };
             InternalUnsafeMethods.Reload()(ObjectPtr, _args);
        }

        /// <description>
        /// Flushes all material instances that use this material.
        /// </description>
        public void Flush() {
             InternalUnsafeMethods.Flush__Args _args = new InternalUnsafeMethods.Flush__Args() {
             };
             InternalUnsafeMethods.Flush()(ObjectPtr, _args);
        }

        /// <description>
        /// Get the type info object for the Material class.
        /// </description>
        /// <returns>The type info object for Material</returns>
        public static EngineTypeInfo StaticGetType() {
             InternalUnsafeMethods.StaticGetType__Args _args = new InternalUnsafeMethods.StaticGetType__Args() {
             };
             IntPtr _engineResult = InternalUnsafeMethods.StaticGetType()(_args);
             return new EngineTypeInfo(_engineResult);
        }


        /// <value>
        /// <description>
        /// Used to map this material to the material name used by TSShape.
        /// </description>
        /// </value>
        public string MapTo {
            get => GenericMarshal.StringTo<string>(GetFieldValue("mapTo"));
            set => SetFieldValue("mapTo", GenericMarshal.ToString(value));
        }


        /// <value>
        /// <description>
        /// This color is multiplied against the diffuse texture color.  If no diffuse texture is present this is the material color.
        /// </description>
        /// </value>
        public DynamicFieldVector<LinearColorF> DiffuseColor {
            get => new DynamicFieldVector<LinearColorF>(
                    this, 
                    "diffuseColor", 
                    4, 
                    val => GenericMarshal.StringTo<LinearColorF>(val),
                    obj => GenericMarshal.ToString(obj)
                );
        }


        /// <value>
        /// <description>
        /// ,yrđ
        /// </description>
        /// </value>
        public DynamicFieldVector<string> DiffuseMap {
            get => new DynamicFieldVector<string>(
                    this, 
                    "DiffuseMap", 
                    4, 
                    val => GenericMarshal.StringTo<string>(val),
                    obj => GenericMarshal.ToString(obj)
                );
        }


        /// <value>
        /// <description>
        /// ,yrđ
        /// </description>
        /// </value>
        public DynamicFieldVector<string> DiffuseMapAsset {
            get => new DynamicFieldVector<string>(
                    this, 
                    "DiffuseMapAsset", 
                    4, 
                    val => GenericMarshal.StringTo<string>(val),
                    obj => GenericMarshal.ToString(obj)
                );
        }


        /// <value>
        /// <description>
        /// ,yrđ
        /// </description>
        /// </value>
        public DynamicFieldVector<string> OverlayMap {
            get => new DynamicFieldVector<string>(
                    this, 
                    "OverlayMap", 
                    4, 
                    val => GenericMarshal.StringTo<string>(val),
                    obj => GenericMarshal.ToString(obj)
                );
        }


        /// <value>
        /// <description>
        /// ,yrđ
        /// </description>
        /// </value>
        public DynamicFieldVector<string> OverlayMapAsset {
            get => new DynamicFieldVector<string>(
                    this, 
                    "OverlayMapAsset", 
                    4, 
                    val => GenericMarshal.StringTo<string>(val),
                    obj => GenericMarshal.ToString(obj)
                );
        }


        /// <value>
        /// <description>
        /// ,yrđ
        /// </description>
        /// </value>
        public DynamicFieldVector<string> LightMap {
            get => new DynamicFieldVector<string>(
                    this, 
                    "LightMap", 
                    4, 
                    val => GenericMarshal.StringTo<string>(val),
                    obj => GenericMarshal.ToString(obj)
                );
        }


        /// <value>
        /// <description>
        /// ,yrđ
        /// </description>
        /// </value>
        public DynamicFieldVector<string> LightMapAsset {
            get => new DynamicFieldVector<string>(
                    this, 
                    "LightMapAsset", 
                    4, 
                    val => GenericMarshal.StringTo<string>(val),
                    obj => GenericMarshal.ToString(obj)
                );
        }


        /// <value>
        /// <description>
        /// ,yrđ
        /// </description>
        /// </value>
        public DynamicFieldVector<string> ToneMap {
            get => new DynamicFieldVector<string>(
                    this, 
                    "ToneMap", 
                    4, 
                    val => GenericMarshal.StringTo<string>(val),
                    obj => GenericMarshal.ToString(obj)
                );
        }


        /// <value>
        /// <description>
        /// ,yrđ
        /// </description>
        /// </value>
        public DynamicFieldVector<string> ToneMapAsset {
            get => new DynamicFieldVector<string>(
                    this, 
                    "ToneMapAsset", 
                    4, 
                    val => GenericMarshal.StringTo<string>(val),
                    obj => GenericMarshal.ToString(obj)
                );
        }


        /// <value>
        /// <description>
        /// ,yrđ
        /// </description>
        /// </value>
        public DynamicFieldVector<string> DetailMap {
            get => new DynamicFieldVector<string>(
                    this, 
                    "detailMap", 
                    4, 
                    val => GenericMarshal.StringTo<string>(val),
                    obj => GenericMarshal.ToString(obj)
                );
        }


        /// <value>
        /// <description>
        /// ,yrđ
        /// </description>
        /// </value>
        public DynamicFieldVector<string> DetailMapAsset {
            get => new DynamicFieldVector<string>(
                    this, 
                    "DetailMapAsset", 
                    4, 
                    val => GenericMarshal.StringTo<string>(val),
                    obj => GenericMarshal.ToString(obj)
                );
        }


        /// <value>
        /// <description>
        /// ,yrđ
        /// </description>
        /// </value>
        public DynamicFieldVector<string> NormalMap {
            get => new DynamicFieldVector<string>(
                    this, 
                    "normalMap", 
                    4, 
                    val => GenericMarshal.StringTo<string>(val),
                    obj => GenericMarshal.ToString(obj)
                );
        }


        /// <value>
        /// <description>
        /// ,yrđ
        /// </description>
        /// </value>
        public DynamicFieldVector<string> NormalMapAsset {
            get => new DynamicFieldVector<string>(
                    this, 
                    "NormalMapAsset", 
                    4, 
                    val => GenericMarshal.StringTo<string>(val),
                    obj => GenericMarshal.ToString(obj)
                );
        }


        /// <value>
        /// <description>
        /// ,yrđ
        /// </description>
        /// </value>
        public DynamicFieldVector<string> PbrConfigMap {
            get => new DynamicFieldVector<string>(
                    this, 
                    "pbrConfigMap", 
                    4, 
                    val => GenericMarshal.StringTo<string>(val),
                    obj => GenericMarshal.ToString(obj)
                );
        }


        /// <value>
        /// <description>
        /// ,yrđ
        /// </description>
        /// </value>
        public DynamicFieldVector<string> PBRConfigMapAsset {
            get => new DynamicFieldVector<string>(
                    this, 
                    "PBRConfigMapAsset", 
                    4, 
                    val => GenericMarshal.StringTo<string>(val),
                    obj => GenericMarshal.ToString(obj)
                );
        }


        /// <value>
        /// <description>
        /// ,yrđ
        /// </description>
        /// </value>
        public DynamicFieldVector<string> RoughMap {
            get => new DynamicFieldVector<string>(
                    this, 
                    "RoughMap", 
                    4, 
                    val => GenericMarshal.StringTo<string>(val),
                    obj => GenericMarshal.ToString(obj)
                );
        }


        /// <value>
        /// <description>
        /// ,yrđ
        /// </description>
        /// </value>
        public DynamicFieldVector<string> RoughMapAsset {
            get => new DynamicFieldVector<string>(
                    this, 
                    "RoughMapAsset", 
                    4, 
                    val => GenericMarshal.StringTo<string>(val),
                    obj => GenericMarshal.ToString(obj)
                );
        }


        /// <value>
        /// <description>
        /// ,yrđ
        /// </description>
        /// </value>
        public DynamicFieldVector<string> AOMap {
            get => new DynamicFieldVector<string>(
                    this, 
                    "AOMap", 
                    4, 
                    val => GenericMarshal.StringTo<string>(val),
                    obj => GenericMarshal.ToString(obj)
                );
        }


        /// <value>
        /// <description>
        /// ,yrđ
        /// </description>
        /// </value>
        public DynamicFieldVector<string> AOMapAsset {
            get => new DynamicFieldVector<string>(
                    this, 
                    "AOMapAsset", 
                    4, 
                    val => GenericMarshal.StringTo<string>(val),
                    obj => GenericMarshal.ToString(obj)
                );
        }


        /// <value>
        /// <description>
        /// ,yrđ
        /// </description>
        /// </value>
        public DynamicFieldVector<string> MetalMap {
            get => new DynamicFieldVector<string>(
                    this, 
                    "MetalMap", 
                    4, 
                    val => GenericMarshal.StringTo<string>(val),
                    obj => GenericMarshal.ToString(obj)
                );
        }


        /// <value>
        /// <description>
        /// ,yrđ
        /// </description>
        /// </value>
        public DynamicFieldVector<string> MetalMapAsset {
            get => new DynamicFieldVector<string>(
                    this, 
                    "MetalMapAsset", 
                    4, 
                    val => GenericMarshal.StringTo<string>(val),
                    obj => GenericMarshal.ToString(obj)
                );
        }


        /// <value>
        /// <description>
        /// ,yrđ
        /// </description>
        /// </value>
        public DynamicFieldVector<string> GlowMap {
            get => new DynamicFieldVector<string>(
                    this, 
                    "GlowMap", 
                    4, 
                    val => GenericMarshal.StringTo<string>(val),
                    obj => GenericMarshal.ToString(obj)
                );
        }


        /// <value>
        /// <description>
        /// ,yrđ
        /// </description>
        /// </value>
        public DynamicFieldVector<string> GlowMapAsset {
            get => new DynamicFieldVector<string>(
                    this, 
                    "GlowMapAsset", 
                    4, 
                    val => GenericMarshal.StringTo<string>(val),
                    obj => GenericMarshal.ToString(obj)
                );
        }


        /// <value>
        /// <description>
        /// ,yrđ
        /// </description>
        /// </value>
        public DynamicFieldVector<string> DetailNormalMap {
            get => new DynamicFieldVector<string>(
                    this, 
                    "DetailNormalMap", 
                    4, 
                    val => GenericMarshal.StringTo<string>(val),
                    obj => GenericMarshal.ToString(obj)
                );
        }


        /// <value>
        /// <description>
        /// ,yrđ
        /// </description>
        /// </value>
        public DynamicFieldVector<string> DetailNormalMapAsset {
            get => new DynamicFieldVector<string>(
                    this, 
                    "DetailNormalMapAsset", 
                    4, 
                    val => GenericMarshal.StringTo<string>(val),
                    obj => GenericMarshal.ToString(obj)
                );
        }


        /// <value>
        /// <description>
        /// Enable sRGB for the diffuse color texture map.
        /// </description>
        /// </value>
        public DynamicFieldVector<bool> DiffuseMapSRGB {
            get => new DynamicFieldVector<bool>(
                    this, 
                    "diffuseMapSRGB", 
                    4, 
                    val => GenericMarshal.StringTo<bool>(val),
                    obj => GenericMarshal.ToString(obj)
                );
        }


        /// <value>
        /// <description>
        /// The scale factor for the detail map.
        /// </description>
        /// </value>
        public DynamicFieldVector<Point2F> DetailScale {
            get => new DynamicFieldVector<Point2F>(
                    this, 
                    "detailScale", 
                    4, 
                    val => GenericMarshal.StringTo<Point2F>(val),
                    obj => GenericMarshal.ToString(obj)
                );
        }


        /// <value>
        /// <description>
        /// Used to scale the strength of the detail normal map when blended with the base normal map.
        /// </description>
        /// </value>
        public DynamicFieldVector<float> DetailNormalMapStrength {
            get => new DynamicFieldVector<float>(
                    this, 
                    "detailNormalMapStrength", 
                    4, 
                    val => GenericMarshal.StringTo<float>(val),
                    obj => GenericMarshal.ToString(obj)
                );
        }


        /// <value>
        /// <description>
        /// The degree of smoothness when not using a PBRConfigMap.
        /// </description>
        /// </value>
        public DynamicFieldVector<float> Smoothness {
            get => new DynamicFieldVector<float>(
                    this, 
                    "smoothness", 
                    4, 
                    val => GenericMarshal.StringTo<float>(val),
                    obj => GenericMarshal.ToString(obj)
                );
        }


        /// <value>
        /// <description>
        /// The degree of Metalness when not using a PBRConfigMap.
        /// </description>
        /// </value>
        public DynamicFieldVector<float> Metalness {
            get => new DynamicFieldVector<float>(
                    this, 
                    "metalness", 
                    4, 
                    val => GenericMarshal.StringTo<float>(val),
                    obj => GenericMarshal.ToString(obj)
                );
        }


        /// <value>
        /// <description>
        /// glow mask multiplier
        /// </description>
        /// </value>
        public DynamicFieldVector<float> GlowMul {
            get => new DynamicFieldVector<float>(
                    this, 
                    "glowMul", 
                    4, 
                    val => GenericMarshal.StringTo<float>(val),
                    obj => GenericMarshal.ToString(obj)
                );
        }


        /// <value>
        /// <description>
        /// Accumulation texture.
        /// </description>
        /// </value>
        public DynamicFieldVector<bool> AccuEnabled {
            get => new DynamicFieldVector<bool>(
                    this, 
                    "accuEnabled", 
                    4, 
                    val => GenericMarshal.StringTo<bool>(val),
                    obj => GenericMarshal.ToString(obj)
                );
        }


        /// <value>
        /// <description>
        /// The scale that is applied to the accu map texture. You can use this to fit the texture to smaller or larger objects.
        /// </description>
        /// </value>
        public DynamicFieldVector<float> AccuScale {
            get => new DynamicFieldVector<float>(
                    this, 
                    "accuScale", 
                    4, 
                    val => GenericMarshal.StringTo<float>(val),
                    obj => GenericMarshal.ToString(obj)
                );
        }


        /// <value>
        /// <description>
        /// The direction of the accumulation. Chose whether you want the accu map to go from top to bottom (ie. snow) or upwards (ie. mold).
        /// </description>
        /// </value>
        public DynamicFieldVector<float> AccuDirection {
            get => new DynamicFieldVector<float>(
                    this, 
                    "accuDirection", 
                    4, 
                    val => GenericMarshal.StringTo<float>(val),
                    obj => GenericMarshal.ToString(obj)
                );
        }


        /// <value>
        /// <description>
        /// The strength of the accu map. This changes the transparency of the accu map texture. Make it subtle or add more contrast.
        /// </description>
        /// </value>
        public DynamicFieldVector<float> AccuStrength {
            get => new DynamicFieldVector<float>(
                    this, 
                    "accuStrength", 
                    4, 
                    val => GenericMarshal.StringTo<float>(val),
                    obj => GenericMarshal.ToString(obj)
                );
        }


        /// <value>
        /// <description>
        /// The coverage ratio of the accu map texture. Use this to make the entire shape pick up some of the accu map texture or none at all.
        /// </description>
        /// </value>
        public DynamicFieldVector<float> AccuCoverage {
            get => new DynamicFieldVector<float>(
                    this, 
                    "accuCoverage", 
                    4, 
                    val => GenericMarshal.StringTo<float>(val),
                    obj => GenericMarshal.ToString(obj)
                );
        }


        /// <value>
        /// <description>
        /// Changes specularity to this value where the accumulated material is present.
        /// </description>
        /// </value>
        public DynamicFieldVector<float> AccuSpecular {
            get => new DynamicFieldVector<float>(
                    this, 
                    "accuSpecular", 
                    4, 
                    val => GenericMarshal.StringTo<float>(val),
                    obj => GenericMarshal.ToString(obj)
                );
        }


        /// <value>
        /// <description>
        /// Substance Designer Workaround.
        /// </description>
        /// </value>
        public DynamicFieldVector<bool> IsSRGB {
            get => new DynamicFieldVector<bool>(
                    this, 
                    "isSRGB", 
                    4, 
                    val => GenericMarshal.StringTo<bool>(val),
                    obj => GenericMarshal.ToString(obj)
                );
        }


        /// <value>
        /// <description>
        /// Treat Smoothness as Roughness
        /// </description>
        /// </value>
        public DynamicFieldVector<bool> InvertSmoothness {
            get => new DynamicFieldVector<bool>(
                    this, 
                    "invertSmoothness", 
                    4, 
                    val => GenericMarshal.StringTo<bool>(val),
                    obj => GenericMarshal.ToString(obj)
                );
        }


        /// <value>
        /// <description>
        /// The input channel smoothness maps use.
        /// </description>
        /// </value>
        public DynamicFieldVector<float> SmoothnessChan {
            get => new DynamicFieldVector<float>(
                    this, 
                    "smoothnessChan", 
                    4, 
                    val => GenericMarshal.StringTo<float>(val),
                    obj => GenericMarshal.ToString(obj)
                );
        }


        /// <value>
        /// <description>
        /// The input channel AO maps use.
        /// </description>
        /// </value>
        public DynamicFieldVector<float> AOChan {
            get => new DynamicFieldVector<float>(
                    this, 
                    "AOChan", 
                    4, 
                    val => GenericMarshal.StringTo<float>(val),
                    obj => GenericMarshal.ToString(obj)
                );
        }


        /// <value>
        /// <description>
        /// The input channel metalness maps use.
        /// </description>
        /// </value>
        public DynamicFieldVector<float> MetalChan {
            get => new DynamicFieldVector<float>(
                    this, 
                    "metalChan", 
                    4, 
                    val => GenericMarshal.StringTo<float>(val),
                    obj => GenericMarshal.ToString(obj)
                );
        }


        /// <value>
        /// <description>
        /// Enables rendering as glowing.
        /// </description>
        /// </value>
        public DynamicFieldVector<bool> Glow {
            get => new DynamicFieldVector<bool>(
                    this, 
                    "glow", 
                    4, 
                    val => GenericMarshal.StringTo<bool>(val),
                    obj => GenericMarshal.ToString(obj)
                );
        }


        /// <value>
        /// <description>
        /// Enables parallax mapping and defines the scale factor for the parallax effect.  Typically this value is less than 0.4 else the effect breaks down.
        /// </description>
        /// </value>
        public DynamicFieldVector<float> ParallaxScale {
            get => new DynamicFieldVector<float>(
                    this, 
                    "parallaxScale", 
                    4, 
                    val => GenericMarshal.StringTo<float>(val),
                    obj => GenericMarshal.ToString(obj)
                );
        }


        /// <value>
        /// <description>
        /// Use anisotropic filtering for the textures of this stage.
        /// </description>
        /// </value>
        public DynamicFieldVector<bool> UseAnisotropic {
            get => new DynamicFieldVector<bool>(
                    this, 
                    "useAnisotropic", 
                    4, 
                    val => GenericMarshal.StringTo<bool>(val),
                    obj => GenericMarshal.ToString(obj)
                );
        }


        /// <value>
        /// <description>
        /// If true the vertex color is used for lighting.
        /// </description>
        /// </value>
        public DynamicFieldVector<bool> VertLit {
            get => new DynamicFieldVector<bool>(
                    this, 
                    "vertLit", 
                    4, 
                    val => GenericMarshal.StringTo<bool>(val),
                    obj => GenericMarshal.ToString(obj)
                );
        }


        /// <value>
        /// <description>
        /// If enabled, vertex colors are premultiplied with diffuse colors.
        /// </description>
        /// </value>
        public DynamicFieldVector<bool> VertColor {
            get => new DynamicFieldVector<bool>(
                    this, 
                    "vertColor", 
                    4, 
                    val => GenericMarshal.StringTo<bool>(val),
                    obj => GenericMarshal.ToString(obj)
                );
        }


        /// <value>
        /// <description>
        /// The Minnaert shading constant value.  Must be greater than 0 to enable the effect.
        /// </description>
        /// </value>
        public DynamicFieldVector<float> MinnaertConstant {
            get => new DynamicFieldVector<float>(
                    this, 
                    "minnaertConstant", 
                    4, 
                    val => GenericMarshal.StringTo<float>(val),
                    obj => GenericMarshal.ToString(obj)
                );
        }


        /// <value>
        /// <description>
        /// Enables the subsurface scattering approximation.
        /// </description>
        /// </value>
        public DynamicFieldVector<bool> SubSurface {
            get => new DynamicFieldVector<bool>(
                    this, 
                    "subSurface", 
                    4, 
                    val => GenericMarshal.StringTo<bool>(val),
                    obj => GenericMarshal.ToString(obj)
                );
        }


        /// <value>
        /// <description>
        /// The color used for the subsurface scattering approximation.
        /// </description>
        /// </value>
        public DynamicFieldVector<LinearColorF> SubSurfaceColor {
            get => new DynamicFieldVector<LinearColorF>(
                    this, 
                    "subSurfaceColor", 
                    4, 
                    val => GenericMarshal.StringTo<LinearColorF>(val),
                    obj => GenericMarshal.ToString(obj)
                );
        }


        /// <value>
        /// <description>
        /// The 0 to 1 rolloff factor used in the subsurface scattering approximation.
        /// </description>
        /// </value>
        public DynamicFieldVector<float> SubSurfaceRolloff {
            get => new DynamicFieldVector<float>(
                    this, 
                    "subSurfaceRolloff", 
                    4, 
                    val => GenericMarshal.StringTo<float>(val),
                    obj => GenericMarshal.ToString(obj)
                );
        }


        /// <value>
        /// <description>
        /// Enables emissive lighting for the material.
        /// </description>
        /// </value>
        public DynamicFieldVector<bool> Emissive {
            get => new DynamicFieldVector<bool>(
                    this, 
                    "emissive", 
                    4, 
                    val => GenericMarshal.StringTo<bool>(val),
                    obj => GenericMarshal.ToString(obj)
                );
        }


        /// <value>
        /// <description>
        /// Disables backface culling casing surfaces to be double sided. Note that the lighting on the backside will be a mirror of the front side of the surface.
        /// </description>
        /// </value>
        public bool DoubleSided {
            get => GenericMarshal.StringTo<bool>(GetFieldValue("doubleSided"));
            set => SetFieldValue("doubleSided", GenericMarshal.ToString(value));
        }


        /// <value>
        /// <description>
        /// The types of animation to play on this material.
        /// </description>
        /// </value>
        public DynamicFieldVector<MaterialAnimType> AnimFlags {
            get => new DynamicFieldVector<MaterialAnimType>(
                    this, 
                    "animFlags", 
                    4, 
                    val => GenericMarshal.StringTo<MaterialAnimType>(val),
                    obj => GenericMarshal.ToString(obj)
                );
        }


        /// <value>
        /// <description>
        /// The scroll direction in UV space when scroll animation is enabled.
        /// </description>
        /// </value>
        public DynamicFieldVector<Point2F> ScrollDir {
            get => new DynamicFieldVector<Point2F>(
                    this, 
                    "scrollDir", 
                    4, 
                    val => GenericMarshal.StringTo<Point2F>(val),
                    obj => GenericMarshal.ToString(obj)
                );
        }


        /// <value>
        /// <description>
        /// The speed to scroll the texture in UVs per second when scroll animation is enabled.
        /// </description>
        /// </value>
        public DynamicFieldVector<float> ScrollSpeed {
            get => new DynamicFieldVector<float>(
                    this, 
                    "scrollSpeed", 
                    4, 
                    val => GenericMarshal.StringTo<float>(val),
                    obj => GenericMarshal.ToString(obj)
                );
        }


        /// <value>
        /// <description>
        /// The speed to rotate the texture in degrees per second when rotation animation is enabled.
        /// </description>
        /// </value>
        public DynamicFieldVector<float> RotSpeed {
            get => new DynamicFieldVector<float>(
                    this, 
                    "rotSpeed", 
                    4, 
                    val => GenericMarshal.StringTo<float>(val),
                    obj => GenericMarshal.ToString(obj)
                );
        }


        /// <value>
        /// <description>
        /// The piviot position in UV coordinates to center the rotation animation.
        /// </description>
        /// </value>
        public DynamicFieldVector<Point2F> RotPivotOffset {
            get => new DynamicFieldVector<Point2F>(
                    this, 
                    "rotPivotOffset", 
                    4, 
                    val => GenericMarshal.StringTo<Point2F>(val),
                    obj => GenericMarshal.ToString(obj)
                );
        }


        /// <value>
        /// <description>
        /// The type of wave animation to perform when wave animation is enabled.
        /// </description>
        /// </value>
        public DynamicFieldVector<MaterialWaveType> WaveType {
            get => new DynamicFieldVector<MaterialWaveType>(
                    this, 
                    "waveType", 
                    4, 
                    val => GenericMarshal.StringTo<MaterialWaveType>(val),
                    obj => GenericMarshal.ToString(obj)
                );
        }


        /// <value>
        /// <description>
        /// The wave frequency when wave animation is enabled.
        /// </description>
        /// </value>
        public DynamicFieldVector<float> WaveFreq {
            get => new DynamicFieldVector<float>(
                    this, 
                    "waveFreq", 
                    4, 
                    val => GenericMarshal.StringTo<float>(val),
                    obj => GenericMarshal.ToString(obj)
                );
        }


        /// <value>
        /// <description>
        /// The wave amplitude when wave animation is enabled.
        /// </description>
        /// </value>
        public DynamicFieldVector<float> WaveAmp {
            get => new DynamicFieldVector<float>(
                    this, 
                    "waveAmp", 
                    4, 
                    val => GenericMarshal.StringTo<float>(val),
                    obj => GenericMarshal.ToString(obj)
                );
        }


        /// <value>
        /// <description>
        /// The number of frames per second for frame based sequence animations if greater than zero.
        /// </description>
        /// </value>
        public DynamicFieldVector<float> SequenceFramePerSec {
            get => new DynamicFieldVector<float>(
                    this, 
                    "sequenceFramePerSec", 
                    4, 
                    val => GenericMarshal.StringTo<float>(val),
                    obj => GenericMarshal.ToString(obj)
                );
        }


        /// <value>
        /// <description>
        /// The size of each frame in UV units for sequence animations.
        /// </description>
        /// </value>
        public DynamicFieldVector<float> SequenceSegmentSize {
            get => new DynamicFieldVector<float>(
                    this, 
                    "sequenceSegmentSize", 
                    4, 
                    val => GenericMarshal.StringTo<float>(val),
                    obj => GenericMarshal.ToString(obj)
                );
        }


        /// <value>
        /// 
        /// </value>
        public DynamicFieldVector<Point2I> CellIndex {
            get => new DynamicFieldVector<Point2I>(
                    this, 
                    "cellIndex", 
                    4, 
                    val => GenericMarshal.StringTo<Point2I>(val),
                    obj => GenericMarshal.ToString(obj)
                );
        }


        /// <value>
        /// 
        /// </value>
        public DynamicFieldVector<Point2I> CellLayout {
            get => new DynamicFieldVector<Point2I>(
                    this, 
                    "cellLayout", 
                    4, 
                    val => GenericMarshal.StringTo<Point2I>(val),
                    obj => GenericMarshal.ToString(obj)
                );
        }


        /// <value>
        /// 
        /// </value>
        public DynamicFieldVector<int> CellSize {
            get => new DynamicFieldVector<int>(
                    this, 
                    "cellSize", 
                    4, 
                    val => GenericMarshal.StringTo<int>(val),
                    obj => GenericMarshal.ToString(obj)
                );
        }


        /// <value>
        /// 
        /// </value>
        public DynamicFieldVector<bool> BumpAtlas {
            get => new DynamicFieldVector<bool>(
                    this, 
                    "bumpAtlas", 
                    4, 
                    val => GenericMarshal.StringTo<bool>(val),
                    obj => GenericMarshal.ToString(obj)
                );
        }


        /// <value>
        /// <description>
        /// For backwards compatibility.
        /// </description>
        /// <see cref="diffuseMap" />
        /// </value>
        public DynamicFieldVector<string> BaseTex {
            get => new DynamicFieldVector<string>(
                    this, 
                    "baseTex", 
                    4, 
                    val => GenericMarshal.StringTo<string>(val),
                    obj => GenericMarshal.ToString(obj)
                );
        }


        /// <value>
        /// <description>
        /// For backwards compatibility.
        /// </description>
        /// <see cref="detailMap" />
        /// </value>
        public DynamicFieldVector<string> DetailTex {
            get => new DynamicFieldVector<string>(
                    this, 
                    "detailTex", 
                    4, 
                    val => GenericMarshal.StringTo<string>(val),
                    obj => GenericMarshal.ToString(obj)
                );
        }


        /// <value>
        /// <description>
        /// For backwards compatibility.
        /// </description>
        /// <see cref="overlayMap" />
        /// </value>
        public DynamicFieldVector<string> OverlayTex {
            get => new DynamicFieldVector<string>(
                    this, 
                    "overlayTex", 
                    4, 
                    val => GenericMarshal.StringTo<string>(val),
                    obj => GenericMarshal.ToString(obj)
                );
        }


        /// <value>
        /// <description>
        /// For backwards compatibility.
        /// </description>
        /// <see cref="normalMap" />
        /// </value>
        public DynamicFieldVector<string> BumpTex {
            get => new DynamicFieldVector<string>(
                    this, 
                    "bumpTex", 
                    4, 
                    val => GenericMarshal.StringTo<string>(val),
                    obj => GenericMarshal.ToString(obj)
                );
        }


        /// <value>
        /// <description>
        /// For backwards compatibility.
        /// </description>
        /// <see cref="diffuseColor" />
        /// </value>
        public DynamicFieldVector<LinearColorF> ColorMultiply {
            get => new DynamicFieldVector<LinearColorF>(
                    this, 
                    "colorMultiply", 
                    4, 
                    val => GenericMarshal.StringTo<LinearColorF>(val),
                    obj => GenericMarshal.ToString(obj)
                );
        }


        /// <value>
        /// <description>
        /// If set to false the lighting system will not cast shadows from this material.
        /// </description>
        /// </value>
        public bool CastShadows {
            get => GenericMarshal.StringTo<bool>(GetFieldValue("castShadows"));
            set => SetFieldValue("castShadows", GenericMarshal.ToString(value));
        }


        /// <value>
        /// 
        /// </value>
        public bool PlanarReflection {
            get => GenericMarshal.StringTo<bool>(GetFieldValue("planarReflection"));
            set => SetFieldValue("planarReflection", GenericMarshal.ToString(value));
        }


        /// <value>
        /// <description>
        /// If true this material is translucent blended.
        /// </description>
        /// </value>
        public bool Translucent {
            get => GenericMarshal.StringTo<bool>(GetFieldValue("translucent"));
            set => SetFieldValue("translucent", GenericMarshal.ToString(value));
        }


        /// <value>
        /// <description>
        /// The type of blend operation to use when the material is translucent.
        /// </description>
        /// </value>
        public MaterialBlendOp TranslucentBlendOp {
            get => GenericMarshal.StringTo<MaterialBlendOp>(GetFieldValue("translucentBlendOp"));
            set => SetFieldValue("translucentBlendOp", GenericMarshal.ToString(value));
        }


        /// <value>
        /// <description>
        /// If enabled and the material is translucent it will write into the depth buffer.
        /// </description>
        /// </value>
        public bool TranslucentZWrite {
            get => GenericMarshal.StringTo<bool>(GetFieldValue("translucentZWrite"));
            set => SetFieldValue("translucentZWrite", GenericMarshal.ToString(value));
        }


        /// <value>
        /// <description>
        /// Enables alpha test when rendering the material.
        /// </description>
        /// <see cref="alphaRef" />
        /// </value>
        public bool AlphaTest {
            get => GenericMarshal.StringTo<bool>(GetFieldValue("alphaTest"));
            set => SetFieldValue("alphaTest", GenericMarshal.ToString(value));
        }


        /// <value>
        /// <description>
        /// The alpha reference value for alpha testing.  Must be between 0 to 255.
        /// </description>
        /// <see cref="alphaTest" />
        /// </value>
        public int AlphaRef {
            get => GenericMarshal.StringTo<int>(GetFieldValue("alphaRef"));
            set => SetFieldValue("alphaRef", GenericMarshal.ToString(value));
        }


        /// <value>
        /// <description>
        /// The name of a CubemapData for environment mapping.
        /// </description>
        /// </value>
        public string Cubemap {
            get => GenericMarshal.StringTo<string>(GetFieldValue("cubemap"));
            set => SetFieldValue("cubemap", GenericMarshal.ToString(value));
        }


        /// <value>
        /// <description>
        /// Enables the material to use the dynamic cubemap from the ShapeBase object its applied to.
        /// </description>
        /// </value>
        public bool DynamicCubemap {
            get => GenericMarshal.StringTo<bool>(GetFieldValue("dynamicCubemap"));
            set => SetFieldValue("dynamicCubemap", GenericMarshal.ToString(value));
        }


        /// <value>
        /// <description>
        /// Whether to show player footprint decals on this material.
        /// </description>
        /// <see cref="PlayerData::decalData" />
        /// </value>
        public bool ShowFootprints {
            get => GenericMarshal.StringTo<bool>(GetFieldValue("showFootprints"));
            set => SetFieldValue("showFootprints", GenericMarshal.ToString(value));
        }


        /// <value>
        /// <description>
        /// Whether to emit dust particles from a shape moving over the material.  This is, for example, used by vehicles or players to decide whether to show dust trails.
        /// </description>
        /// </value>
        public bool ShowDust {
            get => GenericMarshal.StringTo<bool>(GetFieldValue("showDust"));
            set => SetFieldValue("showDust", GenericMarshal.ToString(value));
        }


        /// <value>
        /// <description>
        /// If #showDust is true, this is the set of colors to use for the ParticleData of the dust emitter.
        /// </description>
        /// <see cref="ParticleData::colors" />
        /// </value>
        public DynamicFieldVector<LinearColorF> EffectColor {
            get => new DynamicFieldVector<LinearColorF>(
                    this, 
                    "effectColor", 
                    2, 
                    val => GenericMarshal.StringTo<LinearColorF>(val),
                    obj => GenericMarshal.ToString(obj)
                );
        }


        /// <value>
        /// <description>
        /// What sound to play from the PlayerData sound list when the player walks over the material.  -1 (default) to not play any sound.
        /// 
        /// The IDs are:
        /// 
        /// - 0: PlayerData::FootSoftSound
        /// - 1: PlayerData::FootHardSound
        /// - 2: PlayerData::FootMetalSound
        /// - 3: PlayerData::FootSnowSound
        /// - 4: PlayerData::FootShallowSound
        /// - 5: PlayerData::FootWadingSound
        /// - 6: PlayerData::FootUnderwaterSound
        /// - 7: PlayerData::FootBubblesSound
        /// - 8: PlayerData::movingBubblesSound
        /// - 9: PlayerData::waterBreathSound
        /// - 10: PlayerData::impactSoftSound
        /// - 11: PlayerData::impactHardSound
        /// - 12: PlayerData::impactMetalSound
        /// - 13: PlayerData::impactSnowSound
        /// - 14: PlayerData::impactWaterEasy
        /// - 15: PlayerData::impactWaterMedium
        /// - 16: PlayerData::impactWaterHard
        /// - 17: PlayerData::exitingWater
        /// </description>
        /// </value>
        public int FootstepSoundId {
            get => GenericMarshal.StringTo<int>(GetFieldValue("footstepSoundId"));
            set => SetFieldValue("footstepSoundId", GenericMarshal.ToString(value));
        }


        /// <value>
        /// <description>
        /// The sound to play when the player walks over the material.  If this is set, it overrides #footstepSoundId.  This field is useful for directly assigning custom footstep sounds to materials without having to rely on the PlayerData sound assignment.
        /// </description>
        /// </value>
        public SFXTrack CustomFootstepSound {
            get => GenericMarshal.StringTo<SFXTrack>(GetFieldValue("customFootstepSound"));
            set => SetFieldValue("customFootstepSound", GenericMarshal.ToString(value));
        }


        /// <value>
        /// <description>
        /// What sound to play from the PlayerData sound list when the player impacts on the surface with a velocity equal or greater than PlayerData::groundImpactMinSpeed.
        /// 
        /// For a list of IDs, see #footstepSoundId
        /// </description>
        /// </value>
        public int ImpactSoundId {
            get => GenericMarshal.StringTo<int>(GetFieldValue("impactSoundId"));
            set => SetFieldValue("impactSoundId", GenericMarshal.ToString(value));
        }


        /// <value>
        /// <description>
        /// What FX to play from the PlayerData sound list when the player impacts on the surface with a velocity equal or greater than PlayerData::groundImpactMinSpeed.
        /// 
        /// For a list of IDs, see #impactFXId
        /// </description>
        /// </value>
        public int ImpactFXIndex {
            get => GenericMarshal.StringTo<int>(GetFieldValue("ImpactFXIndex"));
            set => SetFieldValue("ImpactFXIndex", GenericMarshal.ToString(value));
        }


        /// <value>
        /// <description>
        /// The sound to play when the player impacts on the surface with a velocity equal or greater than PlayerData::groundImpactMinSpeed.  If this is set, it overrides #impactSoundId.  This field is useful for directly assigning custom impact sounds to materials without having to rely on the PlayerData sound assignment.
        /// </description>
        /// </value>
        public SFXTrack CustomImpactSound {
            get => GenericMarshal.StringTo<SFXTrack>(GetFieldValue("customImpactSound"));
            set => SetFieldValue("customImpactSound", GenericMarshal.ToString(value));
        }
    }
}